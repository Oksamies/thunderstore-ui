import { GetServerSideProps } from "next";
import { useEffect, useState } from "react";

import { DapperError } from "@thunderstore/dapper";
import { useSession } from "components/SessionContext";
import { getString } from "utils/urlQuery";

export type WithDid404<T> = T & { did404: boolean };

/**
 * Refresh page contents from data API if user is authenticated.
 *
 * The session id used to authenticate the user for the data API is
 * stored in the localStorage and thus isn't available when Next.js
 * renders the initial page on the server-side. This hook can be used to
 * refetch the data on the client-side in case the user is
 * authenticated.
 *
 * Note: to avoid unnecessary requests, this should be used only on
 * pages where the contents can actually differ between an authenticated
 * and unauthenticated user.
 *
 * @param initialProps props for the page that uses this hooks
 * @param dapperMethod data fetching method provided by Dapper
 * @param dapperParams array of parameters passed to dapperMethod
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function useFreshProps<T extends (...args: any) => any>(
  initialProps: WithDid404<Awaited<ReturnType<T>>>,
  dapperMethod: T,
  dapperParams: Parameters<T>
): WithDid404<Awaited<ReturnType<T>>> {
  const { isReady, sessionId } = useSession();
  const [props, setProps] = useState(initialProps);
  const [hasRun, setHasRun] = useState(false);

  useEffect(() => {
    // Postpone sending the request if the session id stored in
    // localStorage isn't validated yet.
    if (!isReady) {
      return;
    }

    // If the unauthenticated server-side request resulted in 404 and
    // the user isn't authenticated, there's no point redoing the request.
    if (initialProps.did404 && sessionId === undefined) {
      throw new DapperError("Not Found", undefined, 404);
    }

    // Avoid unnecessary fetching if
    // * The data fetching has already been initiated
    // * SSR was successful (no 404)
    // * User is unauthenticated (the results would be equal to SSR)
    if (hasRun || !initialProps.did404 || sessionId === undefined) {
      return;
    }

    const fetchData = async () => {
      const data = await dapperMethod(...dapperParams);
      setProps({ ...data, did404: false });
    };

    fetchData();
    setHasRun(true);
  }, [
    dapperMethod,
    dapperParams,
    hasRun,
    initialProps.did404,
    isReady,
    sessionId,
    setHasRun,
    setProps,
  ]);

  return props;
}

/**
 * HOC wrapper for getServerSideProps methods. Suppresses 404 errors
 * generated by unauthenticated Dapper requests on server-side and
 * augments the returned props with `did404` boolean property.
 * Client-side should attempt to redo the request when it detects this
 * "soft 404" flag if the user is authenticated.
 */
export const withSoft404 = (
  gssp: GetServerSideProps,
  urlParamKeys?: string[]
): GetServerSideProps => {
  return async (context) => {
    try {
      const serverSidePropsResult = await gssp(context);

      // For type checking: https://github.com/vercel/next.js/issues/19271
      if (!("props" in serverSidePropsResult)) {
        throw new Error("invalid getServerSideProps result");
      }

      return {
        props: { ...serverSidePropsResult.props, did404: false },
      };
    } catch (e) {
      if (e instanceof DapperError && e.code === 404) {
        // Attempt to include the URL parameters in the props so page
        // can try to refetch data if user is authenticated.
        const urlParams = Object.fromEntries(
          (urlParamKeys ?? []).map((k) => [k, getString(context.params?.[k])])
        );

        return {
          props: { ...urlParams, did404: true },
        };
      }

      throw e;
    }
  };
};
